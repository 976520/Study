# HTTP 기초

> HTTP(HyperText Transfer Protocol)는 웹에서 데이터를 주고받는 서버-클라이언트 모델의 프로토콜이다.
> 

쉽게 설명하자면 웹 브라우저가 서버와 통신하는 규칙이다.

예를 들어 [https://www.hellogsm.kr](https://www.hellogsm.kr/) 라는 링크는 [www.hellogsm.kr](www.hellogsm.kr) 이라는 주소가 가진 데이터의 교환을 HTTP(S)의 통신 규약대로 처리하라는 것을 의미한다.

이 글에서는 우선 프로토콜의 정의를 간단히 요약하고, 그에 기반하여 HTTP에 대해 설명할 것이다. 또한 HTTP에서 사용되는 메시지의 종류를 정리할 것이며, 마지막으로 HTTPS에 대해 알아볼 것이다.

---

## 프로토콜

1. 정의
    
    > 통신 프로토콜 또는 통신 규약은 컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고 받는 양식과 규칙의 체계이다.
    > 
    
    이는 원활한 통신을 위한 것이다. 예를 들어 한국어를 쓰는 우리가 영어권 사람과 대화하는 것 보다, 한국어를 쓰는 사람끼리 대화하는 것이 더 편할 것이다. 따라서 컴퓨터도 같은 프로토콜을 사용해야 통신이 가능하며, 현존하는 모든 컴퓨터는 후술할 TCP/IP 프로토콜을 사용한다.
    
    이 글의 주제인 HTTP도 이러한 프로토콜의 일종으로써, 통신의 규칙을 정한 것이다.
    
2. 종류
    1. **TCP/IP** (Transmission Control Protocol / Internet Protocol)
        
        [TCP/IP](TCP%20IP%20b6ee4387c8a249dc8165a73b3ec5a688.md)
        
    2. **UDP** (User Datagram Protocol)
        
        앞서 서술한 TCP와 비슷하나 수신 여부를 확인하여 신뢰성이 높지만 속도가 느린 TCP에 비해 수신 여부를 확인하지 않는 UDP는 신뢰성이 낮지만 속도가 빠르다.
        
    3. **SMTP** (Simple Mail Transfer Protocol)
        
        간이 우편 전송 프로토콜이라는 이름에서 알 수 있듯이 이메일 전송에 사용되는 네트워크 프로토콜의 한 종류이다.
        
    4. **HTTP** (Hyper Text Transfer Protocol)
        
        인터넷상에서 데이터를 빠르게 교환하기 위한 프로토콜이다. 
        
    5. **HTTPS** (Hyper Text Transfer Protocol Secure)
        
        HTTP의 보안적 약점을 보완하기 위한 프로토콜이다.
        

---

## HTTP 이해

우선 HTTP통신은 클라이언트와 서버로 이분된 구조를 가진다. 

![Untitled](HTTP%E1%84%8B%E1%85%AA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%8F%E1%85%A9%E1%86%AF%20c4c4745814eb49ceaa3d1b3338164e8f/Untitled.png)

1. 특징
    1. TCP/IP를 이용하는 응용 프로토콜이다.
        
        
    2. HTTP는 연결 상태를 유지하지 않는 비연결성 프로토콜이다.
        
        서버와 클라이언트의 연결을 지속하지 않으며, 앞서 언급했듯 요청과 응답 방식으로만 동작한다. 우리가 HelloGSM에 접속을 한다고 가정했을 때, 접속하면 클라이언트는 GET명령을 서버에 전송한다. 요청을 받은 HelloGSM은 응답 코드와 메시지를 전송하고, 그것을 브라우저가 화면에 송출하는 것이다.
        
        연결을 지속한다는 것은 서버와 클라이언트 사이의 연결이 요청 없이도 계속 유지된다는 것을 의미한다. 연결이 계속 유지되는 만큼 자원이 계속 소모된다는 단점이 있다. 따라서 HTTP가 연결을 유지하지 않는 이유는 이러한 자원의 효율성 문제 때문이다.
        
    3. HTTP는 클라이언트와 서버 사이에 상태를 유지하지 않는 무상태 프로토콜이다.
        
        이 때문에 서버 확장성이 높다는 장점이 있으며, 클라이언트가 서버로 요청을 보낼 때 마다 추가로 데이터를 같이 보내야 한다는 단점이 존재한다.
        
    4. HTML Document만이 유일한 HTTP 통신을 위한 데이터는 아니다. 다음과 같은 데이터를 전송할 수 있다.
        1. HTML, text
        2. 이미지, 음성, 영상 등 미디어 파일
        3. JSON, XML(API)
        4. 그 외의 여러 형태의 데이터들..
        
    5. 기본 포트로 80번을 쓴다.
    
2. 동작
    1. 앞서 언급한 대로 HTTP는 무상태 프로토콜이다.
        
        때문에, 클라이언트가 서버에 요청을 보내기 전에 Connect(연결)하는 작업이 요구되며, 서버의 응답을 받으면 Close(종료)된다.
        
    2. 클라이언트의 요청에 대해 서버가 응답하는 구조를 가진다.
        
        부연하자면, 클라이언트, 즉 사용자가 브라우저를 통해서 Request를 하면 서버에서는 해당 요청에 맞는 결과를 찾아 사용자에게 Response(응답)하는 것이다. 서버간에 데이터를 주고받을 때 대부분 HTTP 프로토콜을 이용한다고 봐도 무방하다.
        

---

## HTTP 메시지

1. Request
    1. HTTP 요청 메시지 형식은 다음과 같다.
        
        ![Untitled](HTTP%E1%84%8B%E1%85%AA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%8F%E1%85%A9%E1%86%AF%20c4c4745814eb49ceaa3d1b3338164e8f/Untitled%201.png)
        
        1. Start line
            
            메소드 + URL + 버전 으로 이루어져있다. 
            
            URL은 대상 경로를 표시하는 것이며, 버전은 사용된 HTTP의 버전을 뜻한다.
            
        2. headers
            
            여기는 HTTP 전송에 필요한 모든 부가 정보를 담는 곳이다.
            
        3. blank line
            
            요청에 대한 모든 메타 정보가 전송되었음을 알리는 용도이다.
            
        4. body
            
            요청을 할 때 함께 보낼 데이터를 담는 부분으로, GET, HEAD, DELETE, OPTIONS처럼 리소스를 가져요는 요청은 Body에 포함하지 않는다.
            
        
    2. 다음은 HTTP에서 지원하는 메소드의 일부를 기술한 것이다.
        1. GET
            
            리소스를 조회한다. 메시지 바디를 이용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 더 많아서 권장하지 않는다.
            
        2. POST
            
            요청 데이터를 처리한다.  메시지 바디를 이용해서 서버로 요청 데이터를 전달하며, 서버는 이를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다. 
            
        3. PUT
            
            만약 리소스가 있을 시 이를 완전히 대체하며, 없을 시 리소스를 생성한다.
            
            ![Untitled](HTTP%E1%84%8B%E1%85%AA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%8F%E1%85%A9%E1%86%AF%20c4c4745814eb49ceaa3d1b3338164e8f/Untitled%202.png)
            
            ![Untitled](HTTP%E1%84%8B%E1%85%AA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%8F%E1%85%A9%E1%86%AF%20c4c4745814eb49ceaa3d1b3338164e8f/Untitled%203.png)
            
        4. PATCH
            
            만약 리소스가 있을 시 요청한 부분만 대체한다.
            
            ![Untitled](HTTP%E1%84%8B%E1%85%AA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%8F%E1%85%A9%E1%86%AF%20c4c4745814eb49ceaa3d1b3338164e8f/Untitled%204.png)
            
            ![Untitled](HTTP%E1%84%8B%E1%85%AA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%8F%E1%85%A9%E1%86%AF%20c4c4745814eb49ceaa3d1b3338164e8f/Untitled%205.png)
            
        5. DELETE
            
            리소스를 제거한다.
            
        6. HEAD
            
            헤더 정보만 요청한다.
            
        7. OPTIONS
            
            서버가 지원하는 메서드의 종류를 받는다.
            
        8. TRACE
            
            클라이언트가 서버에 송신한 내용을 반환한다.
            
        
2. Response
    
    HTTP state라고 하며, HTTP요청에 대한 서버의 응답 코드이다. 이는 첫번째 숫자에 따라 크게 5가지로 분류된다.
    
    1. 1XX (Informational), 조건부 응답
        
        요청이 수신되어 작업을 진행 중 이라는 의미이다.
        
        1. 100 (Continue)
            
            요청에 문제가 없으니 다음 요청을 이어서 보내라는 의미이다.
            
        2. 101 (Switching Protocols)
        3. 102 (Processing)
            
            요청을 처리하고 있지만 아직 제대로 된 응답을 할 수 없다는 의미이다.
            
        4. 103 (Early Hints)
            
            서버가 응답을 준비하는 동안 사용자가 PreLoading을 할 수 있게 하는 코드이다.
            
    2. 2XX (Successful), 성공
        
        요청을 정상적으로 처리했음을 뜻한다.
        
        1. 200 (OK)
            
            요청이 성공적으로 처리했다는 것을 뜻하며, 주로 GET요청에 대한 응답으로 쓰인다.
            
        2. 201(Created)
            
            요청이 성공적으로 수행되어서 새 리소스가 생성되었음을 의미하며, 주로 POST요청에 대한 응답으로 쓰인다.
            
        3. 202 (Accepted)
            
            요청은 받아들여졌지만, 처리되지 않았음을 의미한다.
            
        4. 203 (Non-Authoritative Information)
            
            요청이 성공적으로 수행되었으나, 요청에 대한 검증이 되지 않음을 의미한다.
            
        5. 204 (No Content)
            
            요청이 성공적으로 수행되었지만, Content를 제공할 수 없는 상태임을 의미한다. 주로 DELETE 요청에 대한 응답으로 쓰인다.
            
        6. 205 (Reset Content)
            
            서버가 요청을 성공적으로 처리했지만, Content를 표시하지 않는다는 의미이다.
            
        7. 206 (Partial Content)
            
            서버가 요청의 일부만을 성공적으로 처리했음을 의미한다.
            
        
    3. 3XX (Redirection), 리다이렉션
        
        요청을 완료하기 위해 추가 동작(Redirection)이 필요함을 의미한다. 자동으로 헤더의 location 필드의 URL을 보내서 Redirect한다.
        
        1. 300 (Multiple Choices)
            
            요청에 대한 리소스가 여러개 존재함을 의미한다.
            
        2. 301 (Moved Permanently)
            
            영구적으로 Content가 이동했을 때 사용된다.
            
        3. 302 (Found)
            
            일시적으로 Content가 이동했을 때 사용된다.
            
        4. 303 (See Other)
            
            요청한 리소스를 다른 URL에서 GET요청을 통해 얻어야 할 때 사용된다.
            
        5. 304 (Not Modified)
            
            리소스가 수정되지 않음을 의미한다. 이를 받을 시, 클라이언트는 서버로부터 리소스를 재전송 받지 않고, 브라우저에 캐싱된 리소스를 사용한다.
            
        6. 307 (Temporary Redirect)
            
            302와 동일하게 일시적으로 Content가 이동했을 때 사용되나, HTTP 메소드의 변경을 허용하지 않는다.
            
        7. 308 (Permanent Redirect)
            
            301와 동일하게 영구적으로 Content가 이동했을 때 사용되나, HTTP 메소드의 변경을 허용하지 않는다.
            
        
    4. 4XX (Client Error), 클라이언트 오류
        
        클라이언트의 요청의 잘못된 문법 등으로 서버가 요청을 수행할 수 없을 때 발생한다. 이미 클라이언트가 잘못된 요청을 보내고 있기 때문에, 같은 요청을 다시 보내도 실패한다.
        
        1. 400 (Bad Request)
            
            클라이언트의 잘못된 요청으로 인해 서버가 요청을 처리할 수 없다는 의미이다.
            
        2. 401 (Unauthorized)
            
            클라이언트가 해당 리소스에 대한 인증이 필요한 상태일 때 사용된다.
            
        3. 403 (Forbidden)
            
            서버가 요청을 이해하기는 했지만, 승인을 거부했을 때 사용된다,
            
        4. 404 (Not Found)
            
            요청 리소스를 찾을 수 없을 때 사용된다.
            
        5. 405 (Method Not Allowed)
            
            현재 리소스에 맞지 않는 메소드를 요청했음을 의미한다.
            
        6. 406 (No Acceptable)
            
            알맞은 Content 타입이 없음을 의미한다. 즉, 서버의 리소스가 클라이언트의 HTTP 헤더에 들어있는 Accpet 필드에 명시된 콘텐츠 타입이 아닌 경우에 해당한다.
            
        7. 407 (Proxy Authentication Required)
            
            프록시 인증이 필요하다는 의미이다.
            
        8. 408 (Request Timeout)
            
            요청 중 시간이 초과되었을 때 사용된다.
            
        
    5. 5XX (Server Error), 서버 오류
        
        서버의 문제로 인해 요청을 실행할 수 없을 때 발생한다. 문제가 서버에 있기 때문에, 같은 요청을 다시 보내면 성공할 수 있다.
        
        1. 500 (Internal Server Error)
            
            서버에 오류가 발생하여 응답할 수 없거나, 처리 방법을 알 수 없을 경우에 사용한다.
            
        2. 501 (Not Implemented)
            
            클라이언트 요청에 대한 서버의 응답 수행 기능이 없음을 의미한다.
            
        3. 502 (Bad Gateway)
            
            서버의 부모 서버에서 오류가 발생한 경우에 사용되며, 일반적으로 접속자가 많아 과부하가 된 경우의 응답이다.
            
        4. 503 (Service Unavailable)
            
            서버가 요청을 처리할 준비가 되지 않았음을 의미한다.
            
    

---

## HTTPS

1. 정의
    
    > HTTPS는 웹 브라우저와 웹 사이트 간에 데이터를 전송하는 데 사용되는 기본 프로토콜인 HTTP의 보안 버전이다.
    > 
    
    기존 HTTP는 브라우저와 웹서버가 통신함에 있어 데이터를 암호화하지 않고 그대로 전송되었다. 그렇기 때문에 해커가 중간에서 통신을 도청하게 된다면 충분히 정보를 탈취할 수 있다. 
    
    HTTPS는 SSL(Secure Sockes Layer)이 선행하는 TLS(Transport Layer Security)라는 암호화 프로토콜을 사용하여 브라우저와 서버 간에 전달되는 모든 데이터를 암호화함으로써 이러한 보안적 약점을 해결하였다.
    
2. 특징
    1. TLS는 전송 계층의 보안이라는 뜻으로 기존의 SSL에 기반하여 인터넷에서의 정보를 암호화하여 송수신하는 프로토콜이다. HTTPS는 곧 TLS와 HTTP가 조합된 프로토콜을 가리킨다.
        
        
    2. 데이터를 주고 받는 과정에서 데이터의 암호화와 복호화 과정을 거치기 때문에 기존의 HTTP보다 속도가 다소 느릴 수 있지만, 이 차이는 거의 체감하지 못한다.
        
        
    3. 기본 포트로 443번을 쓴다.
    

---