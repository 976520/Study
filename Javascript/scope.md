# 4배율 스코프

함수의 매개변수는 함수 내부에서만 참조할 수 있는데, 이것이 매게변수를 참조할 수 있는 '유효범위'가 함수 내부로 한정되기 때문이다.

> 스코프는 다른 코드가 해당 식별자를 참조할 수 있는, 즉 해당 식별자가 유효한 범위이다.

모든 함수, 변수, 클래스 등은 자신이 선언된 위치에 의해 스코프가 결정된다.

스코프는 다음 두가지로 구분된다.

1. 동적(dynamic) 스코프

    함수가 호출되는 시점에 상위 스코프를 결정하는 방식이다.
   
2. lexical 스코프

    static 스코프와 같은 말이다.

    함수를 어디서 정의했는지에 따라 상위 스코프를 결정하는 방식으로, JS가 이 방식을 따른다. ~~동적 스코프 잊어벼려도 된다.~~

---

## identifier resolution

> identifier resolution(식별자 결정)은 JS 엔진이 여러 식별자 중 누구를 참조해야 할 지 결정하는 과정이다. 

다음 코드에서는 함수의 안과 바깥에서 같은 이름을 가진 변수를 선언했고, 다시 함수의 안과 바깥에서 `console.log`로 변수를 호출했다. 

```javascript
var 변수 = 'global';

function 함수() {
  var 변수 = 'local';

  console.log(변수); // 출력: local
}

함수();

console.log(변수); // 출력: global
```

바깥에서 선언된 `변수`는 어디서든 참조할 수 있지만, `함수()`의 내부에서 선언된 `변수`는 `함수()`의 바깥에서 참조할 수 없다. 두 `변수`는 이름이 동일하지만 스코프가 다른 별개의 식별자이다.

대부분의 언어에서 당연하게, **식별자는 유일(unique)**해야 한다. 하나의 식별자는 그것에 연결된 하나의 데이터를 구분할 수 있어야 하기 때문이다 (name binding). 

예를 들어 컴퓨터의 파일시스템에서 식별자인 파일명은 유일해야 하지만 컴퓨터 전체에서 파일명을 유일하게 하려면 번거롭기 때문에 다른 디렉토리에서는 파일명의 중복을 허용한다. 이처럼 프로그래밍 언어에서도 특정 스코프 내에서의 식별자는 유일하게 하지만 다른 스코프에서는 같은 식별자를 사용할 수 있게 하여 식별자 충돌을 방지한다. 스코프가 곧 namespace인 것이다.

---

## 종류

  1. 전역(global)

     최상위 스코프이자 코드의 가장 바깥 영역이며, 여기에 선언한 변수는 어디서든지 참조가 가능하다.

  2. 지역(local)

     지역에 변수를 선언하면 지역 스코프를 가지는 지역 변수가 되고, 이는 자신의 지역 스코프와 그 하위 지역 스코프에서 참조할 수 있다.

     지역 스코프는 다시 둘로 나뉜다.

     1. 함수 레벨 스코프

     2. 블록 레벨 스코프

     특별한건 아니고 둘 다 지역인건 같은데

     ```javascript
      function 함수() {
        var a = 1; // 이건 함수 레벨

        if (true) {
          var b = 2; // 이건 블록 레벨
        }
      }
     ```
     이 정도의 사소한 차이가 있다.

---

## 스코프 체인

1. 정의

    JS에서는 중첩된 함수(nested function)을 자주 볼 수 있다. 함수가 중첩됨에 따라 각 함수의 스코프도 중첩되는데, 이렇게 스코프가 **계층적인 구조**를 갖는 것을 **스코프 체인**이라고 한다. 
 
    ```javascript
    function 이건첫번째레슨() {
      function 이제두번째레슨() {
        function 드디어세번째레슨() {
          // ...
        }
      }
    }
    ```

    한 변수에 대해 identifier resolution를 할 때 스코프 체인을 통해 해당 변수를 참조하는 스코프에서 시작하여 상위 방향으로 이동하며 식별자를 검색한다. 이에 따라 다음이 성립한다.
        
    1. 모든 지역 스코프의 최상위 스코프가 전역 스코프이다.

    2. 상위 스코프에서 유효한 식별자는 하위 스코프에서 참조할 수 있지만, 반대의 경우는 불가하다.

2. LexicalEnvironment

    스코프가 실제로는 `LexicalEnvironment`라는 자료구조를 통해 구현되어 있다. JS 엔진은 creation phase(생성 단계)에 이 자료구조를 생성하는데, 다음과 같은 구성요소를 가진다.

    - `EnvironmentRecord`

      식별자 정보가 저장된다. 선언이 일어나면 식별자가 key에 등록되고, 할당이 일어나면 value를 변경한다.

    - `Outer`

      상위 `LexicalEnvironment`를 가리키는 참조이다.

    > 스코프 체인은 이 LexicalEnvironment들이 `Outer` 참조로 연결(chaining)된 논리적 구조이다.

    JS 엔진은 한 변수에 대해 identifier resolution를 할 때 현재 실행 중인 context의 `LexicalEnvironment`에서 시작하여 `Outer`를 따라 상위로 올라가며 해당 식별자가 등록된 `EnvironmentRecord`를 탐색한다.

---