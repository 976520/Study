# 객체 지향 프로그래밍

> OOP(Object Oriented Programming)은 프로그램을 수많은 객체(object)라는 기본 단위로 나누고 이들의 상호 작용으로 서술하는 방법론이다.

우선 객체에 대해 이해해야 한다.

---

## 개념

1. 객체

   현실 세계에서의 객체는 구체적인 사물 혹은 추상적인 개념을 뜻한다. 또한 객체는 state(상태)와 behaver(동작)으로 구성된다. 예를 들어 이주언 이라는 객체는 '서 있음', '앉아 있음' 과 같은 state, '서다', '앉다' 와 같은 behaver으로 구성되어 있다.

   소프트웨어에서의 객체도 비슷한 원리를 지닌다. 단지 state가 field로, behaver가 method로 정의되어있을 뿐이다. field는 객체를 통하여 사용할 수 있는 변수이며, method는 객체를 통하여 호출할 수 있는 동작이다.

   현실 세계의 객체는 개별적으로 사용할 수 있고, 다른 객체와 상호작용할 수도 있다. 예를 들어 이주언이 권재헌을 때리면 이주언에게는 쾌감이, 권재헌에게는 통증이 발생하듯이, 현실 세계에서 발생하는 여러 현상은 객체가 서로 상호작용하여 발생한다.

   소프트웨어에서도 객체는 개별적으로 사용하거나 다른 객체와의 관계를 맺으며 동작할 수 있다. 대부분의 소프트웨어는 다수의 객체로 구성되며, 이들이 상호작용하여 문제를 해결한다. 이러한 문제 해결 방식을 취한 프로그램을 작성하는 것이 OOP라고 할 수 있다.

   OOP에서는 현실 세계를 객체 단위로 프로그래밍한다. 소프트웨어에서 객체는 데이터, 즉 field와 그의 동작 method를 묶어 표현하는 구성 요소라고 정리할 수 있다.

2. Procedural programming(절차적 프로그래밍)과의 비교

   Procedural programming은 동작을 순서에 맞추어 단계적으로 실행되도록 명령어를 나열한다. 데이터의 정의보다 명령의 순서와 흐름에 중점을 둔다. 소규모 프로젝트의 경우 수행할 작업을 예측할 수 있어 직관적이고 프로그래밍하기 쉽다는 장점이 있다.

   하지만 프로젝트 규모의 증대에 따라 이에 따른 한계가 부각될 것이다. 서로 복잡하게 얽힌 데이터를 그의 동작과 분리하여 사용하였기 때문에 추후 변경이나 확장에 난관을 겪을 수 밖에 없다.

   현실 세계의 작업은 절차나 과정보다는 이와 관련한 많은 객체의 상호작용으로 표현하는 것이 효과적이다. 이러한 현실 세계의 특성을 고려하고 procedural programming의 한계를 극복한 것이 OOP이다.

3. class

   제품을 만들기 위해 재료와 함께 설계도가 필요하다. 전통적으로 이를 붕어빵으로 예를 들어 설명한다. 붕어빵이라는 객체는 반죽, 앙금 등의 재료로 만들어지지만, 이것들을 붕어빵으로 만들기 위해서는 붕어빵 형틀(template)가 불가결적이다. OOP의 class가 이 동일한 객체를 생산하는 틀 혹은 설계도라고 할 수 있다.

   Class라는 틀로 만든 객체가 해당 클래스의 instance이다. 예를 들어 붕어빵은 붕어빵 형틀의 instance가 된다. 이와 같이 클래스에서 객체를 생성하는 과정을 instantiation이라고 한다.

   객체는 field와 method로 구성되므로, class도 field와 method를 정의해놓아야 한다. OOP에서는 class의 field와 method를 정의한 후 이를 기반으로 필요한 객체를 생성한다.

---

## 요소

1. 캡슐화(encapsulation)

   변수와 메서드를 하나의 단위로 묶는 것을 의미하며, 이를 데이터의 캡슐화라고 할 수 있습니다. 자바에서는 클래스(class)를 통해 이를 구현하고, 해당 클래스의 인스턴스를 생성하여 클래스 안의 멤버 변수와 메서드에 쉽게 접근할 수 있다.

   > 정보 은닉(information hiding)은 프로그램의 세부 구현을 외부로 드러나지 않도록 특정 모듈 내부로 감추는 것이다.

   캡슐화의 의의는 이 정보 은닉에 있다. 컴퓨터 본체의 부품이 모두 노출된다면 실수로 쉽게 고장을 낼 수 있으므로 부품을 케이스에 담아 보호하는 것과 같은 목적이다. Java에서도 외부로부터 보호하고 싶은 field나 method가 있다면 캡슐화함으로써 외부에서 접근할 수 없도록 사용 범위를 제한할 수 있다. 일반적으로 다음 세 종류의 접근 지정자(access modifier)가 사용된다.

   1. `public`

      Class의 외부에서 사용 가능하도록 노출시킨다. 한마디로 어디서든 접근할 수 있다.

   2. `protected`

      다른 class에게는 노출하지 않지만 동일 패키지 내의 class나, 상속받은 하위 class에게는 노출한다. 다른 패키지의 class에게는 노출되지 않는다.

   3. `default`

      `protected`와 동일하게 동일 패키지 내의 class에게 노출한다. 그러나 하위 class에게 노출하지 않는다.

   4. `private`

      클래스의 내부에서만 사용하며 외부로 노출하지 않는다.

   컴퓨터의 RAM이 고장 났을 때 다른 RAM으로 교체하면 정상적으로 작동한다. 마찬가지로 class 내부의 캡슐화된 코드는 독립적으로 관리되어 동일한 기능이라면 다른 코드로 대체될 수 있다. 이를 통해 코드의 모듈화 편의성과 재사용성을 높일 수 있다.

2. 상속(inheritance)

   상속은 하위 객체가 상위 객체의 특성과 기능을 물려받는 것을 뜻한다. 상속받은 하위 객체가 상위 객체의 method와 field를 사용할 수 있게 되며, 이는 재사용성을 높인다.

   이때 상위 객체 class를 parent(부모) class, super class, base(기본) class 라고 하기도 하며, 하위 객체 class를 child(자식) class, subclass, derived(파생) class, extended(확장) class라고 하기도 한다.

   **Overriding은 하위 class가 상위 class에서 상속받은 method를 자신에게 맞게 재정의하는 것**을 말한다. 예를 들어 human이라는 class를 상속받아 권재헌, 이주언, 황지훈 등 하위 class를 추가할 수 있다. 상위 class의 method를 그대로 사용하지 않고, 하위 class의 상황에 맞게 동작하도록 변경할 수 있다. overriding된 method는 하위 class에서 호출될 때, 상위 class의 method가 아닌 하위 class에서 재정의된 method가 실행된다.

   다른 예시로, human class에 greet()라는 method가 있다고 가정하면, 이주언 class는 이 method를 overriding하여 "hello, i'm 이주언."라고 인사하도록 변경할 수 있다. 이때 권재헌 class는 "hello, i'm nigga."와 같이 다르게 overriding할 수 있다. 이러한 overriding을 통해 코드의 유연성과 확장성을 높일 수 있다.

3. 다형성

---

## 원칙
