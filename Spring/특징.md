## Spring 특징

1.  POJO(Plain Old Java Object)

2.  AOP(Aspect Oriented Programming)

3.  DI(Dependency Injection)

    Layer, service 간에 dependency가 존재하는 경우 spring이 서로 연결해주는 역할을 한다. Spring에서는 다음 세 방법을 통해 dependency injection을 구현할 수 있다.

    1.  field injection

        Field에 바로 `@Autowired` annotation을 붙여 dependency를 주입하는 방식이다.

        ```java
        @Service
        public class Service {}

        @Component
        public class Client {
            @Autowired
            private Service service;
        }
        ```

        코드가 간결하다는 장점이 있지만, immutable(불변) 객체를 생성할 수 없다는 단점이 있다.

    2.  constructor injection

        Class의 constructor에 `@Autowired` annotation을 붙여 dependency를 주입하는 방식이다.

        ```java
        @Service
        public class Service {}

        @Component
        public class Client {
            private final Service service;

            @Autowired // <-- constructor가 1개인 경우 생략 가능
            public Client(Service service) {
                this.service = service;
            }
        }
        ```

        Constructor injection은 객체 생성 시점에 필요한 모든 dependency를 주입받는다. 따라서 instance가 생성될 때 한 번만 호출된다.

        객체 생성 후에는 주입받은 dependency가 변경되지 않도록 `final` 키워드를 사용하여 immutable 객체를 생성할 수 있다. 이는 SOLID원칙 중 Open-Closed Principal을 준수하는 것이다. 객체 초기화가 생성 시점에 이루어지므로, NullPointerException과 같은 runtime error를 사전에 방지할 수 있다.

        또한 compile 시점에서 누락된 dependency와 circular reference(순환 참조)를 확인할 수 있다는 장점도 있다.

        Circular reference는 두 객체가 서로를 field에 포함하여 참조하는 경우를 의미한다. 때문에 두 class가 맞물려 서로의 객체를 무한히 생성하게 된다.

    3.  setter injection

        Class의 setter method에 `@Autowired` annotation을 붙여 dependency를 주입하는 방식이다.

        ```java
        @Service
        public class Service {}

        @Component
        public class Client {
            private Service service;

            @Autowired
            public void setService(Service service) {
                this.service = service;
            }
        }
        ```

        Constructor injection과 유사하지만, setter injection에서는 주입받는 객체가 `final`이 아니기 때문에, 객체의 생성 이후에도 주입받는 객체를 변경할 수 있다. 따라서 주입받는 객체가 변경될 가능성이 있거나, 객체의 생성 시점에 모든 dependency를 주입받을 수 없는 경우에 setter injection을 사용한다.

        하지만 이는 불필요한 객체 수정의 가능성을 내포하고 있으므로, SOLID원칙 중 Open-Closed Principal을 위배하는 것이다.

4.  IoC(Inversion of Control)

    IOC는

5.  Bean lifecycle

6.  transaction management

7.  MVC pattern

8.  batch processing

---
